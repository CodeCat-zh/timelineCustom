---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lihangyu.
--- DateTime: 2021/8/27 10:18
---

module("Polaris.Cutscene",package.seeall)

EffectController = class("EffectController")

local Mathf = UnityEngine.Mathf
local UNSET_TIME = -1

function EffectController:Awake()
    
end

function EffectController:SetParams(params,assetPrefab,loadedCallback)
    self.scale = params.scale or 1
    self.pos = params.pos or Vector3.zero
    self.rot = params.rot or Vector3.zero
    self.assetPrefab = assetPrefab
    self.duration = params.duration or 300
    self.loadedCallback = loadedCallback
    self.particleSystems = {}
end


function EffectController:OnDestroy()
    if not goutil.IsNil(self.effectGO) then
        self.effectGO.transform:SetParent(nil)
        CutsceneUtil.DestroyObject(self.effectGO)
        self.effectGO = nil
    end
end

function EffectController:GetEffectGO()
    return self.effectGO
end

function EffectController:Init()
    if not self.assetPrefab then
        return
    end
    self.lastTime = UNSET_TIME
    self.systemTime = 0
    self.effectGO = UnityEngine.Object.Instantiate(self.assetPrefab)
    self:RemoveUnusedComponent()
    self:ApplyEffectProperty()
    if self.loadedCallback then
        self.loadedCallback(self.effectGO)
        self.loadedCallback = nil
    end
    self:SetRenderLayer(LayerMask.NameToLayer("Effect"))
    self:InitParticleSystems()
    self:StartPlay()
end

function EffectController:ApplyEffectProperty()
    local localScale = self.effectGO.transform.localScale
    localScale.x = localScale.x * self.scale
    localScale.y = localScale.y * self.scale
    localScale.z = localScale.z * self.scale

    self.effectGO:SetParent(self.gameObject)
    self.effectGO.transform.localPosition = self.pos
    self.effectGO.transform.localEulerAngles = self.rot
    self.effectGO.transform.localScale = localScale
end

function EffectController:RemoveUnusedComponent()
    local unusedComponentTypes  ={
        typeof(Polaris.ToLuaFramework.ObjectPoolComponent),
        typeof(Polaris.ToLuaFramework.DelayDespawn)
    }

    for _,v in ipairs(unusedComponentTypes) do
        local component = self.effectGO:GetComponent(v)
        if component then
            CutsceneUtil.DestroyObject(component)
        end
    end
end 

function EffectController:InitParticleSystems()
    local list = self.effectGO:GetComponentsInChildren(typeof(UnityEngine.ParticleSystem))
    local length = list.Length
    for i = 0, length - 1, 1 do
        table.insert(self.particleSystems, list[i])
    end
end

function EffectController:SetRenderLayer(layerMask)
    local renderers = self.effectGO:GetComponentsInChildren(typeof(UnityEngine.Renderer))
    local length = renderers.Length
    for i=0, length-1, 1 do
        renderers[i].gameObject.layer = layerMask
    end
end

function EffectController:CheckAssetInstantiate()
    return not goutil.IsNil(self.effectGO)
end

function EffectController:Pause()
    for _, v in ipairs(self.particleSystems) do
        if not v:__eq(nil) then
            v:Pause()
        end
    end
end

function EffectController:Continue()
    for _, v in ipairs(self.particleSystems) do
        if not v:__eq(nil) then
            v:Play()
        end
    end
end

function EffectController:StartPlay()
    local animators = self.effectGO:GetComponentsInChildren(typeof(UnityEngine.Animator))
    if(animators) then
        local animatorLength = animators.Length
        for i = 0, animatorLength - 1, 1 do
            local animator = animators[i]
            animator:Rebind()
            animator:StopPlayback()
            animator.recorderStartTime = 0
            animator:StartRecording(self.duration)
            local frameRate = UnityEngine.Application.targetFrameRate
            local frameCount = (self.duration * frameRate) + 2
            for i=0,frameCount - 1 do
                animator:Update(1/frameRate)
            end
            animator:StopRecording()
            animator:StartPlayback()
            animator.playbackTime = 0
            animator:Update(0)
        end
    end
end

function EffectController:PlayParticle(time)
    --for _, v in ipairs(self.particleSystems) do
    --    if not v:__eq(nil) then
    --        v:Simulate(time, true)
    --    end
    --end
    local rootParticleSystem = self.particleSystems[1]
    self:_PlayParticle(rootParticleSystem, time)
end

function EffectController:_PlayParticle(particleSystem, time)
    if not particleSystem or not particleSystem.gameObject or not particleSystem.gameObject.activeInHierarchy then
        return
    end
    local localTime = time
    local shouldUpdate = Mathf.Approximately(self.lastTime, UNSET_TIME) or not Mathf.Approximately(self.lastTime, localTime)
    if shouldUpdate then
        local epsilon = Time.fixedDeltaTime * 0.5
        local simTime = localTime
        local expectedDelta = simTime - self.lastTime

        --  The first iteration includes the start delay. Evaluate(particleSystem.randomSeed) is how the particle system generates the random value internally.
        local startDelay = 0--particleSystem.main.startDelay.Evaluate(tonumber(particleSystem.randomSeed))
        local particleSystemDurationLoop0 = particleSystem.main.duration + startDelay

        -- The particle system time does not include the start delay so we need to remove this for our own system time.
        local expectedSystemTime = simTime > particleSystemDurationLoop0 and self.systemTime or self.systemTime - startDelay

        -- if it's not looping, then the system time won't advance past the end of the duration
        if not particleSystem.main.loop then
            expectedSystemTime = math.min(expectedSystemTime, particleSystem.main.duration)
        end

        -- conditions for restart
        local restart = (simTime < self.lastTime) or -- time went backwards
                (simTime < epsilon) or -- time is set to 0
                Mathf.Approximately(self.lastTime, UNSET_TIME) or -- object disabled
                (expectedDelta > particleSystem.main.duration) or -- large jump (bug workaround)
                not (Mathf.Abs(expectedSystemTime - particleSystem.time) < Time.maximumParticleDeltaTime) -- particle system isn't where we left it
        if restart then
            -- work around for a bug where simulate(simTime, true, true) doesn't work on loops
            particleSystem:Simulate(0, true, true)
            particleSystem:Simulate(simTime, true, false)
            self.systemTime = simTime
        else
            -- ps.time will wrap, so we need to account for that in computing delta time
            local particleSystemDuration = simTime > particleSystemDurationLoop0 and particleSystem.main.duration or particleSystemDurationLoop0
            local fracTime = simTime % particleSystemDuration
            local deltaTime = fracTime - self.systemTime

            if deltaTime < -epsilon then -- detect wrapping of ps.time
                deltaTime = fracTime + particleSystemDurationLoop0 - self.systemTime
            end

            particleSystem:Simulate(deltaTime, true, false)
            self.systemTime = self.systemTime + deltaTime
        end

        self.lastTime = localTime
    end
end